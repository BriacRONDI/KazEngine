#version 450

#define max_lod_count 5

layout (set=0, binding=0, std140) readonly uniform Camera
{
	mat4 projection;
	mat4 view;
	vec4 frustum_planes[6];
	vec4 position;
} camera;

layout (set=1, binding=0, std140) readonly buffer Entity
{
	mat4 model[];
};

struct FRAME
{
	int animation_id;
	uint frame_id;
};

layout (set=1, binding=1, std430) writeonly buffer EntityFrame
{
	FRAME frames[];
};

struct ANIMATION
{
	uint frame_count;
	uint loop;
	uint play;
	uint duration;
	uint start;
	float speed;
};

layout (set=1, binding=2, std430) readonly buffer EntityAnimation
{
	ANIMATION animations[];
};

struct MOVEMENT_DATA {
	vec2 destination;
	int moving;
	float radius;
	int grid_position[4];
	int skeleton_id;
	int padding[3];
};

layout (set=1, binding=3) buffer EntityMovement
{
	MOVEMENT_DATA movement[];
};

struct INDIRECT_COMMAND 
{
	uint indexCount;
	uint instanceCount;
	uint firstVertex;
	uint firstInstance;
	uint lodIndex;
};

layout (set=2, binding=0, std430) writeonly buffer IndirectDraws
{
	INDIRECT_COMMAND indirect_draws[];
};

struct LOD
{
	uint first_vertex;
	uint vertex_count;
	float distance;
	uint valid;
};

struct LOD_STACK
{
	LOD stack[max_lod_count];
};

layout (set=3, binding=0, std140) readonly buffer LodData
{
	LOD_STACK lod[];
};

layout (set=4, binding=0) readonly uniform GlobalTime
{
	uint now;
	float delta;
}time;

layout (set=5, binding=0) readonly uniform GridMeta
{
	uint width;
	uint height;
	uint depth;
	float size;
}grid_meta;

layout (set=5, binding=1) buffer GridData
{
	int grid[];
};

bool InsideFrustum(vec4 pos, float radius)
{
	for(int i=0; i<6; i++)
		if(dot(pos, camera.frustum_planes[i]) + radius < 0.0) return false;
	return true;
}

void main()
{
	uint idx = gl_GlobalInvocationID.x;
	
	if(!InsideFrustum(model[idx][3], 2.0)) {
		indirect_draws[idx].instanceCount = 0;
	} else {
		indirect_draws[idx].instanceCount = 1;
		
		ANIMATION animation = animations[idx];
		if(animation.play > 0) {
			if(animation.loop > 0) {
			
				float progression = float(time.now - animation.start) / float(animation.duration) * animation.speed;
				uint last_frame_id = animation.frame_count - 1;
				frames[idx].frame_id = uint(mod(progression * last_frame_id, last_frame_id));
			}else{
			
				// TODO : Play animation once
				// frames[idx].frame_id = 0;
			}
		}else{
		
			frames[idx].frame_id = animation.start;
		}
		
		LOD selected_lod = lod[indirect_draws[idx].lodIndex].stack[0];
		float distance_to_camera = distance(camera.position.xyz, model[idx][3].xyz);
		for(int i=1; i<max_lod_count; i++) {
			LOD current_lod = lod[indirect_draws[idx].lodIndex].stack[i];
			if(current_lod.valid == 0) break;
			if(distance_to_camera > current_lod.distance) selected_lod = current_lod;
		}
		
		indirect_draws[idx].firstVertex = selected_lod.first_vertex;
		indirect_draws[idx].indexCount = selected_lod.vertex_count;
	}
	
	for(int i=0; i<4; i++) {
		int grid_id = movement[idx].grid_position[i];
		if(grid_id >= 0) {
			grid[grid_id] = -1;
			movement[idx].grid_position[i] = -1;
		}
	}
	
	uint half_width = grid_meta.width / 2;
	ivec2 grid_min = ivec2(floor(model[idx][3].x - movement[idx].radius) + half_width, floor(model[idx][3].z - movement[idx].radius) + half_width);
	ivec2 grid_max = ivec2(floor(model[idx][3].x + movement[idx].radius) + half_width, floor(model[idx][3].z + movement[idx].radius) + half_width);
	
	int grid_record = 0;
	for(uint y = grid_min.y; y <= grid_max.y; y++) {
		for(uint x = grid_min.x; x <= grid_max.x; x++) {
			uint grid_square = (y * grid_meta.width + x) * grid_meta.depth;
			for(uint z=0; z<grid_meta.depth; z++) {
				int grid_id = int(grid_square + z);
				if(grid[grid_id] < 0) {
					grid[grid_id] = int(idx);
					movement[idx].grid_position[grid_record] = grid_id;
					grid_record++;
					break;
				}
			}
		}
	}
}